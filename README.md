# PR2

## Завдання 2.1

### Існує проблема, яка має назву Year 2038 problem, яка виражається в тому, що в 2038 році, всі 32-бітні системи у змінниій time_t вичерпають к-сть секунд (2,147,483,647) з моменту 1 січня 1970 року. Якщо коротко, то в 2038 році пройде більше секунд, ніж може в собі вмістити time_t на 32-бітних чичтемах (але не на 64-бітних!). І завдання знайти в секундах, скільки залишилося часу до цього "фінально-фатального" дня для 32-бітних.

## Завдання 2.2
### Створили програму Hello World!
![alt text](image-2.png)
Перевіримо її через ls -l та size
![alt text](image-3.png)

### Створимо там масив із 1000 int
![alt text](image.png)
### Знову проведемо операцію з ls -l та size
### Як ми бачимо, у наз значно збільшився bss, що означає, що ми маємо багато неоголошених змінних, які представляє собою наш масив int
![alt text](image-4.png)

### Тепер присвоїмо для нашого масиву хоча б одну змінну, що дозволить прибрати його із сегменту bss
![alt text](image-5.png)
![alt text](image-6.png)

### Після цього, додамо локальну функцію, де оголосимо великий масив та присвоїмо йому певну змінну.
### Зробимо вже відому нам перевірку через ls -l та size.
![alt text](image-7.png)
![alt text](image-8.png)
### Як ми бачимо, ми не отримали якусь зміну в сегменті bss, проте отримали приріст значень у сегменті text, адже всі функції та їх вміст займають саме ці сегменти
### Якщо глобальна змінна не ініціалізована, то комп'ютер запише її як bss, проте при ініціалізації, вона записується в сегмент data

### При компіляції у режимі debug, всі невикористані змінні зберігаються, так само, як і будь-який інший, "мертвий", код. За рахунок цього, розмір сегментів переважно залишається, як є
### А от при компіляції в режимі оптимізації, компілятор прибирає все, що не є, або не може бути задіяним задля зменшення коду. Це варто враховувати при програмуванні складних схем в мікроконтролерах, типу багатопоточності, різних типів взаємодії в коді, де є змінні, які компілятор може вважати невикористаними. Загалом, це зменшить розмір сегметнів) 

## Завдання 2.3

### Метою виконання цього завдання є розуміння розташування різних сегментів всередині програми
### Трошки модифікувавши наданий нам код шляхом додавання різних типів даних та виведення їх позиції в пам'яті, можемо детально визначити де знаходяться, які сегменти:
![alt text](image-9.png)
![alt text](image-10.png)
### До речі, в Linux відлік (а відповідно й ієрархія) даних починається з кінцевих значень в пам'яті (0x000000000000 - остання комірка) 

## Завдання 2.4

### Для початку повторимо програму, яка надана в прикладі та запустимо її:
![alt text](image-11.png)
![alt text](image-12.png)
### Як ми бачимо, під час запуску ми отримаємо адресу кожної змінної з кожної функції, які запускаються в конкретному порядку, відповідно до нашого графу
![alt text](image-13.png)

### Давайте проведемо дослідження gdb та gstack:
Дізнаємося pid (Proccess ID) для нашого скомпільованого виконавчого файлу:
![alt text](image-14.png)

Через те, що gstack, так само, як і pstack не працюють на моїй версії Ubuntu:
![alt text](image-15.png)
Скористаємося gdb для кожного pid:
![alt text](image-16.png)
![alt text](image-17.png)

### Як ми бачимо, 